

 
 PHP使用了引用计数（reference counting）GC机制，同时使用根缓冲区机制，当php发现有存在循环引用的zval时，就会把其投入到根缓冲区，当根缓冲区达到指定数量后，就会进行垃圾回收，以此解决循环引用导致的内存泄漏问题。
 
 
 每个php变量存在一个叫"zval"的变量容器中。一个zval变量容器，除了包含变量的类型和值，还包含"is_ref"，是个bool值，用来标识这个变量是否是属于引用集合(reference set)，区分普通变量和引用变量；还有一个内部引用计数机制，来优化内存使用。第二个额外字节是"refcount"，用以表示指向这个zval变量容器的引用次数。


回收周期：引用计数系统中的同步周期回收
将所有可能的根放入根缓存区。引用次数减少到非0值，才会产生垃圾周期，进入根缓存区。
根缓存区满时，执行循环查找算法。（模拟删除（引用减1）,模拟恢复（引用加1），真的删除）


垃圾缓冲区是一个双向链表，等到缓存区满了以后则启动垃圾检查过程：遍历缓冲区，对当前变量的所有成员进行遍历，然后把成员的 refcount 减 1 (如果成员还包含子成员则也进行递归遍历，即深度优先遍历)，最后再检查当前变量的引用，如果减为了 0 则为垃圾。这个算法的原理核心是：垃圾是由于成员引用自身导致的，那么就对所有的成员减一遍引用，如果发现最后变量本身的 refcount 变为了 0 则就表明其引用全部来自自身成员，即其他任何地方都不再使用它，那么它就是垃圾，需要被回收掉。反之说明不是垃圾，需要将其从缓冲区移出去。具体的过程如下：


(1) 从缓冲区链表的 roots 开始遍历，把当前 value 标为灰色 (zend\_refcounted\_h.gc\_info 置为 GC\_GREY)，然后对当前 value 的成员进行深度优先遍历，把成员 value 的 refcount 减 1，并且也标为灰色；


(2) 重复遍历缓冲区链表，检查当前 value 引用是否为 0，为 0 则表示确实是垃圾，把它标为白色 (GC\_WHITE)，如果不为 0 则排除了引用全部来自自身成员的可能，表示还有外部的引用，并不是垃圾，这时候因为步骤 (1) 对成员进行了 refcount 减 1 操作，需要再还原回去，对所有成员进行深度遍历，把成员 refcount 加 1，同时标为黑色；


(3) 再次遍历缓冲区链表，将非 GC\_WHITE 的节点从 roots 链表中移出，最终 roots 链表中全部为真正的垃圾，最后将这些垃圾清除。




