



### 哈希
redis的哈希表使用链地址法解决哈希冲突：当发生哈希冲突时，多个哈希表节点通过next指针构成一个单向链表，新节点总是添加到链表的表头位置。
*  哈希步骤
添加元素的过程：1>通过字典的哈希函数，计算出key的hash值，2>根据hash值和sizemask值计算出索引值，3>根据索引值插入到字典中。
* 扩容和收缩
**负载因子 = 哈希表已保存节点数量 / 哈希表大小，哈希表扩容会变成原来的2倍，收缩会变成原来的1/2。** 
 为了让哈希表的负载因子维持在一个合理的范围内（0.1=<load factory<1），当哈希表保存的键值对太多或者太少时，程序需要对哈希表进行扩容或者收缩。扩容和收缩都是通过rehash完成。


    - 将保存在ht[0]上的所有键值对rehash到ht[1]上面：rehash的过程是重新计算hash值以及索引值，然后根据索引值插入到ht[1]哈希表的指定索引上。当ht[0]所有键值对都rehash到ht[1]上后，释放ht[0]，将ht[1]设置为ht[0]，并新建一个空白的哈希表作为ht[1]。
* 扩容什么时候发生


  * 程序没有执行BGSAVE命令或者BGREWRITEAOF(AOF重写)命令，并且哈希表的负载因子大于等于1
  * 如果程序正在执行BGSAVE或者BGREWRITEAOF(AOF重写)命令并且哈希表的负载因子大于等于5。在执行RDB或者AOF重写操作时，redis会创建当前服务器的子进程执行相应操作，为了避免在子进程存在期间对哈希表进行扩展操作，将扩展因子提高。


* 收缩什么时候发生
  * 负载因子小于0.1进行收缩
* 扩容收缩时机
  * 负载因子小于1一定不扩容
  * 负载因子大于5一定扩容
  * 负载因子如果在1-5之间，redis没有进行save/rewrite的操作就会扩容
  * 负载因子如果是0.1，那么会进行缩容


* 渐进式rehash：
    扩展和收缩需要将ht[0]上的所有键值对rehash到ht[1]哈希表中。但是redis的rehash动作并不是一次性完成的，而是分多次、渐进式的完成的。把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作和redis无法访问。一次性redash过程中庞大的计算量会导致服务器在一段时间内停止服务。
- 渐进式rehash步骤
    -ht[1]分配空间中字典值rehashidx初始值为-1。
  - ht[1]分配空间将字典中的rehashidx设置为0，表示rehash正式开始，rehash期间，不会阻塞CRUD等操作，处理一个请求时顺带redash将ht[0]中table[0]处理
  -ht[0]中table[0]数据处理好之后，等下次请求并处理table[1]的数据，并置redashidx为1
  * 当ht\[0]所有的键值对都rehash到ht\[1]时，将rehashidx属性设置成-1，表示rehash完成


* 渐进式
渐进式rehash的过程中，字典同时使用ht\[0],ht\[1]两个哈希表，渐进式rehash期间，字典的删除、查找、更新操作会在2个哈希表上进行。比如：查找一个键时，检查redashidx是否开始，否则根据ht[0]表计算索引值，如果索引值大于redashidx，则redash未执行当前索引，则去ht[0]查找，否则去ht\[1]查找。但是，在渐进式rehash期间，新添加到字典的键值对会保存到ht\[1]哈希表中，而ht\[0]中不会做任何操作，保证ht\[0]只减不增，否则会增加rehash的时间。


### 布隆过滤器


* 是由一串很长的二进制向量组成的数据结构。里面存放的不是0，就是1，但是初始默认值都是0。可以判断某个数据一定不存在，但是无法判断一定存在。数据存在一个不是1的情况，那么该新数据一定不存在这个布隆过滤器中。
* 使用场景：1>垃圾邮箱的过滤。2>新的网站url是否已经爬过。
* 优点：二进制组成的数组，占用内存极少，并且插入和查询速度都足够快。
* 缺点：随着数据增加，`误判率增加`，无法判断数据一定存在，`无法删除数据`。


### BitMap
* 用一个比特位映射某个元素的状态。由于一个比特位只能表示0和1两种状态。所以BitMap能映射的状态有限，使用比特位的优势是能大量节省内存空间。


BitMap底层是基于Redis的字符串类型实现的。（BitMap占用的空间就是底层字符串占用的空间，offset最大值8\*1024\*1024\*512=2^32-1）


* 使用场景：
    1.  用户签到：key = 年份:用户id; offset = (今天是一年中的第几天) % （今年的天数）
    2. 统计活跃用户 key=使用日期；offset=用户ID
    3. 统计用户是否在线 key：固定值；offset=用户ID，
    4. 实现布隆过滤器


> 命令
getbit key offset 设置值
setbit key offset value 获取值
bitcount key start end 统计指定范围内1的个数